name: Release Workflow

on:
  push:
    branches:
      - 6.16-test

permissions:
  contents: write

jobs:
  create_releases:
    runs-on: ubuntu-latest
    outputs:
      new_releases: ${{ steps.version_step.outputs.new_releases }}
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required to analyze all commits

      - name: Process packages and create releases
        id: version_step
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          #!/bin/bash

          # 确保脚本在出错时立即退出
          set -e

          PACKAGES_LIST=$(cat .release-tarballs | grep -v '^$')
          RELEASES_JSON="[]"

          for pkg in ${PACKAGES_LIST}; do
            echo "--- Processing package: ${pkg} ---"

            # 修复 1: 在 if 条件语句后面添加 'then'
            if [ -f .no-auto-version ] && grep -qx "${pkg}" .no-auto-version; then
              echo "Skipping ${pkg} as it is in the auto-version ignore list."
              continue
            fi

            LATEST_TAG=$(git tag --list "${pkg}-v*" --sort=-v:refname | head -n 1)
            STARTING_POINT=""
            if [ -z "$LATEST_TAG" ]; then
              echo "No previous tag found for ${pkg}."
              # 如果没有标签，则从第一次提交开始计算
              STARTING_POINT="HEAD"
            else
              echo "Latest tag for ${pkg} is ${LATEST_TAG}"
              STARTING_POINT="${LATEST_TAG}..HEAD"
            fi

            # --no-merges 选项可以排除合并提交，使日志更干净
            COMMITS_SINCE_LAST_TAG=$(git log ${STARTING_POINT} --pretty=format:"%H %s" --no-merges -- "${pkg}")
            if [ -z "$COMMITS_SINCE_LAST_TAG" ]; then
              echo "No new commits for ${pkg}. Skipping."
              continue
            fi

            echo "Found new commits: ${COMMITS_SINCE_LAST_TAG}"

            IS_MAJOR=false; IS_MINOR=false; IS_PATCH=false
            
            # 修复 3: 使用进程替换 < <(...) 来读取COMMITS_SINCE_LAST_TAG
            # 这样可以避免 `while` 循环在子 Shell 中运行，从而保证循环内对变量的修改在循环外依然有效
            while IFS= read -r commit_line; do
              COMMIT_HASH=$(echo "$commit_line" | cut -d' ' -f1)
              if git show -s --format=%b "${COMMIT_HASH}" | grep -q "BREAKING CHANGE"; then IS_MAJOR=true; fi
              
              COMMIT_SUBJECT=$(echo "$commit_line" | cut -d' ' -f2-)
              
              # 修复 2: 使用正确的 Shell 模式匹配 (Globbing) 来检测提交类型
              # 'fix(' 和 'feat(' 后面的 '*' 是通配符，可以匹配任意字符
              if [[ "${COMMIT_SUBJECT}" == feat\(** ]]; then IS_MINOR=true; fi
              if [[ "${COMMIT_SUBJECT}" == fix\(** ]]; then IS_PATCH=true; fi
            done < <(echo "${COMMITS_SINCE_LAST_TAG}")

            NEXT_VERSION=""
            if [ -z "$LATEST_TAG" ]; then
              # 如果没有历史版本，则从 0.1.0 开始
              NEXT_VERSION="0.1.0"
            else
              # 从标签中提取版本号，例如 "pkg-v1.2.3" -> "1.2.3"
              CURRENT_VERSION=$(echo "${LATEST_TAG}" | sed "s/^${pkg}-v//")
              IFS='.' read -r -a V_PARTS <<< "${CURRENT_VERSION}"
              MAJOR=${V_PARTS[0]}; MINOR=${V_PARTS[1]}; PATCH=${V_PARTS[2]}

              if [ "${IS_MAJOR}" = true ]; then MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0;
              elif [ "${IS_MINOR}" = true ]; then MINOR=$((MINOR + 1)); PATCH=0;
              elif [ "${IS_PATCH}" = true ]; then PATCH=$((PATCH + 1));
              else
                echo "No version-bumping commits for ${pkg}. Skipping."
                continue
              fi
              NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            fi
            
            NEW_TAG="${pkg}-v${NEXT_VERSION}"
            echo "New version for ${pkg} is ${NEXT_VERSION}. Creating release ${NEW_TAG}"

            # 创建发布资源
            rm -rf release_assets && mkdir -p release_assets
            tarball_name="${pkg}-${NEXT_VERSION}.tar.gz"
            # 使用 git archive 创建归档
            (cd "${pkg}" && git archive --format=tar.gz --prefix="${pkg}-${NEXT_VERSION}/" -o "${OLDPWD}/release_assets/${tarball_name}" HEAD .)
            
            # 使用 gh CLI 创建 GitHub Release
            gh release create "${NEW_TAG}" "release_assets/${tarball_name}" --generate-notes --title "Release ${NEW_TAG}"

            RELEASES_JSON=$(echo "${RELEASES_JSON}" | jq -c --arg pkg "$pkg" --arg ver "$NEXT_VERSION" --arg tag "$NEW_TAG" '. + [{package: $pkg, version: $ver, tag: $tag}]')
          done

          echo "new_releases=${RELEASES_JSON}" >> "$GITHUB_OUTPUT"

  # trigger_copr_builds:
  #   needs: create_releases
  #   if: needs.create_releases.outputs.new_releases != '[]'
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix: ${{ fromJson(needs.create_releases.outputs.new_releases) }}
    
  #   env:
  #     COPR_PROJECT: "jhuang6451/nabu_fedora_packages_uefi"
  #     COPR_CHROOTS: "fedora-42-aarch64"
  #     PACKAGE_NAME: ${{ matrix.package }}
  #     VERSION: ${{ matrix.version }}
  #     TAG_NAME: ${{ matrix.tag }}

  #   steps:
  #     - name: Check out code
  #       uses: actions/checkout@v4
  #       with:
  #         ref: ${{ matrix.tag }}

  #     - name: Install Copr CLI
  #       run: sudo pip3 install copr-cli

  #     - name: Configure Copr credentials
  #       run: |
  #         mkdir -p ~/.config
  #         echo "[copr-cli]" > ~/.config/copr
  #         echo "login = ${{ secrets.COPR_LOGIN }}" >> ~/.config/copr
  #         echo "username = ${{ secrets.COPR_USERNAME }}" >> ~/.config/copr
  #         echo "token = ${{ secrets.COPR_TOKEN }}" >> ~/.config/copr
  #         echo "copr_url = ${{ secrets.COPR_API_URL }}" >> ~/.config/copr

  #     - name: Trigger COPR build
  #       run: |
  #         REPO_URL="https://github.com/${{ github.repository }}.git"
  #         echo "Triggering COPR build for ${PACKAGE_NAME} tag ${TAG_NAME}"
          
  #         SPEC_PATH="${PACKAGE_NAME}/${PACKAGE_NAME}.spec"
  #         if [ "$PACKAGE_NAME" == "kernel-sm8150" ]; then
  #           SPEC_PATH="kernel-sm8150/linux-sm8150.spec"
  #         fi
          
  #         for chroot in ${{ env.COPR_CHROOTS }};
  #           copr-cli build-scm \
  #             --chroot "${chroot}" \
  #             --spec "${SPEC_PATH}" \
  #             --method git \
  #             --git-url "${REPO_URL}" \
  #             --git-commit "${TAG_NAME}" \
  #             --rpmbuild-define "version ${VERSION}" \
  #             "${{ env.COPR_PROJECT }}"
  #         done