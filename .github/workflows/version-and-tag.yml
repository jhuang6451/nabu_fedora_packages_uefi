name: Auto Version and Tag

on:
  push:
    branches:
      - 6.16-test

permissions:
  contents: write

jobs:
  tag:
    runs-on: ubuntu-latest
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required to analyze all commits

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Read package list and create tags
        run: |
          # Read file content, filter out empty lines
          PACKAGES_LIST=$(cat release-tarballs.txt | grep -v ''^$'')

          for pkg in ${PACKAGES_LIST}; do
            echo "Processing package: ${pkg}"

            # Check if package is in the ignore list
            if [ -f .no-auto-version ] && grep -qx "${pkg}" .no-auto-version; then
              echo "Skipping ${pkg} as it is in the auto-version ignore list."
              continue
            fi

            # Find the latest tag for this package
            LATEST_TAG=$(git tag --list "${pkg}-v*" --sort=-v:refname | head -n 1)
            
            COMMITS_SINCE_LAST_TAG=""
            STARTING_POINT=""

            if [ -z "$LATEST_TAG" ]; then
              echo "No previous tag found for ${pkg}. Looking at all commits for this package."
              STARTING_POINT="" # No starting tag, so log will check all history for the path
            else
              echo "Latest tag for ${pkg} is ${LATEST_TAG}"
              STARTING_POINT="${LATEST_TAG}..HEAD"
            fi

            # Get commits since the last tag for this package''s path
            COMMITS_SINCE_LAST_TAG=$(git log ${STARTING_POINT} --pretty=format:"%H %s" -- "${pkg}")
            
            if [ -z "$COMMITS_SINCE_LAST_TAG" ]; then
              echo "No new commits for ${pkg} since last tag/initial commit. Skipping."
              continue
            fi

            echo "Found new commits for ${pkg}:"
            echo "${COMMITS_SINCE_LAST_TAG}"

            # Determine the type of change
            IS_MAJOR=false
            IS_MINOR=false
            IS_PATCH=false

            # Use a while loop to read commits line by line
            echo "${COMMITS_SINCE_LAST_TAG}" | while IFS= read -r commit_line; do
              # Check for BREAKING CHANGE in the full commit body
              COMMIT_HASH=$(echo "$commit_line" | cut -d'' '' -f1)
              if git show -s --format=%b ${COMMIT_HASH} | grep -q "BREAKING CHANGE"; then
                IS_MAJOR=true
              fi
              
              # Check the commit subject
              COMMIT_SUBJECT=$(echo "$commit_line" | cut -d'' '' -f2-)
              if [[ "${COMMIT_SUBJECT}" == "feat("* ]]; then
                IS_MINOR=true
              elif [[ "${COMMIT_SUBJECT}" == "fix("* ]]; then
                IS_PATCH=true
              fi
            done

            # Calculate next version
            NEXT_VERSION=""
            if [ -z "$LATEST_TAG" ]; then
                # If no previous tag, any change warrants an initial version.
                NEXT_VERSION="0.1.0"
            else
                CURRENT_VERSION=$(echo ${LATEST_TAG} | sed "s/^${pkg}-v//")
                IFS=''.' read -r -a V_PARTS <<< "${CURRENT_VERSION}"
                MAJOR=${V_PARTS[0]}
                MINOR=${V_PARTS[1]}
                PATCH=${V_PARTS[2]}

                if ${IS_MAJOR}; then
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                elif ${IS_MINOR}; then
                  MINOR=$((MINOR + 1))
                  PATCH=0
                elif ${IS_PATCH}; then
                  PATCH=$((PATCH + 1))
                else
                  echo "No version-bumping commits found for ${pkg}. Skipping."
                  continue
                fi
                NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            fi

            NEW_TAG="${pkg}-v${NEXT_VERSION}"
            echo "New version for ${pkg} is ${NEXT_VERSION}. Creating tag ${NEW_TAG}"
            
            # Create and push the new tag
            git tag "${NEW_TAG}"
            git push origin "${NEW_TAG}"
          done
